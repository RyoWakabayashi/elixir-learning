# Image division

```elixir
Mix.install([
  {:nx, "~> 0.4"},
  {:evision, "~> 0.1"},
  {:req, "~> 0.3"},
  {:kino, "~> 0.8"}
])
```

## Get the image

```elixir
# Download the image
img_path = "lenna.png"

Req.get!(
  "https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png",
  output: img_path
)

img_mat = Evision.imread(img_path)
```

```elixir
# Get the filename, extension, shape
{file_basename, file_ext, img_shape} = {
  Path.basename(img_path, Path.extname(img_path)),
  Path.extname(img_path),
  img_mat.shape
}
```

```elixir
# function to save image tensor list
save_img_tensor_list = fn img_tensor_list, kind ->
  img_tensor_list
  |> Enum.with_index()
  |> Enum.map(fn {img_tensor, index} ->
    dst_filename = "#{file_basename}_#{kind}_#{index}#{file_ext}"

    img_mat = Evision.Mat.from_nx_2d(img_tensor)

    Evision.imwrite(dst_filename, img_mat)

    dst_filename
  end)
end
```

## Divide horizontally

```elixir
# Number of pixels in width and height of the divided image
chunk_size = 64
```

```elixir
# Display divided images
img_mat
|> Evision.Mat.to_nx(Nx.BinaryBackend)
|> Nx.to_batched(chunk_size)
# BGR to RGB
|> Enum.map(&Nx.reverse(&1, axes: [2]))
|> Enum.map(&Kino.Image.new(&1))
|> Kino.Layout.grid(columns: 1)
|> dbg()
```

```elixir
# Save divided images
img_mat
|> Evision.Mat.to_nx(Nx.BinaryBackend)
|> Nx.to_batched(chunk_size)
|> save_img_tensor_list.("h")
```

```elixir
# Concatenate divided images
Stream.unfold(0, fn counter -> {counter, counter + 1} end)
|> Stream.map(&{&1, "#{file_basename}_h_#{&1}#{file_ext}"})
|> Stream.take_while(fn {_, f} -> File.exists?(f) end)
|> Enum.map(fn {index, filename} ->
  new_tensor =
    filename
    |> Evision.imread()
    |> Evision.Mat.to_nx(Nx.BinaryBackend)

  # Invert color for even numbers
  case rem(index, 2) do
    0 ->
      Nx.reverse(new_tensor, axes: [2])

    _ ->
      new_tensor
  end
end)
|> Nx.concatenate()
# Trim to image size
|> Nx.slice([0, 0, 0], Tuple.to_list(img_shape))
|> Kino.Image.new()
```

## Divide vertically

```elixir
# Display split images
img_mat
|> Evision.Mat.to_nx(Nx.BinaryBackend)
# Swap the vertical and horizontal
|> Nx.transpose(axes: [1, 0, 2])
# Divide
|> Nx.to_batched(chunk_size)
# Swap the vertical and horizontal
|> Enum.map(&Nx.transpose(&1, axes: [1, 0, 2]))
# BGR to RGB
|> Enum.map(&Nx.reverse(&1, axes: [2]))
|> Enum.map(&Kino.Image.new(&1))
|> Kino.Layout.grid(columns: 8)
|> dbg()
```

```elixir
# Save divided images
img_mat
|> Evision.Mat.to_nx(Nx.BinaryBackend)
# Swap the vertical and horizontal
|> Nx.transpose(axes: [1, 0, 2])
# Divide
|> Nx.to_batched(chunk_size)
|> Enum.map(&Nx.transpose(&1, axes: [1, 0, 2]))
|> save_img_tensor_list.("v")
```

```elixir
# Concatenate divided images
Stream.unfold(0, fn counter -> {counter, counter + 1} end)
|> Stream.map(&{&1, "#{file_basename}_v_#{&1}#{file_ext}"})
|> Stream.take_while(fn {_, f} -> File.exists?(f) end)
|> Enum.map(fn {index, filename} ->
  new_tensor =
    filename
    |> Evision.imread()
    |> Evision.Mat.to_nx(Nx.BinaryBackend)

  # Invert color for even numbers
  case rem(index, 2) do
    0 ->
      Nx.reverse(new_tensor, axes: [2])

    _ ->
      new_tensor
  end
end)
|> Nx.concatenate(axis: 1)
# Trim to image size
|> Nx.slice([0, 0, 0], Tuple.to_list(img_shape))
|> Kino.Image.new()
```

## Divide into tiles

```elixir
# Display split images
img_mat
|> Evision.Mat.to_nx(Nx.BinaryBackend)
# Divide horizontally
|> Nx.to_batched(chunk_size)
# Divide vertically
|> Enum.map(&Nx.transpose(&1, axes: [1, 0, 2]))
|> Enum.flat_map(&Nx.to_batched(&1, chunk_size))
|> Enum.map(&Nx.transpose(&1, axes: [1, 0, 2]))
# BGR to RGB
|> Enum.map(&Nx.reverse(&1, axes: [2]))
|> Enum.map(&Kino.Image.new(&1))
|> Kino.Layout.grid(columns: 8)
|> dbg()
```

```elixir
# Save divided images
img_mat
|> Evision.Mat.to_nx(Nx.BinaryBackend)
# Divide horizontally
|> Nx.to_batched(chunk_size)
# Divide vertically
|> Enum.map(&Nx.transpose(&1, axes: [1, 0, 2]))
|> Enum.flat_map(&Nx.to_batched(&1, chunk_size))
|> Enum.map(&Nx.transpose(&1, axes: [1, 0, 2]))
|> save_img_tensor_list.("t")
```

```elixir
{width, _, _} = img_shape
h_size = div(width, chunk_size)

# Concatenate divided images
Stream.unfold(0, fn counter -> {counter, counter + 1} end)
|> Stream.map(&{&1, "#{file_basename}_t_#{&1}#{file_ext}"})
|> Stream.take_while(fn {_, f} -> File.exists?(f) end)
|> Enum.map(fn {t_index, filename} ->
  new_tensor =
    filename
    |> Evision.imread()
    |> Evision.Mat.to_nx(Nx.BinaryBackend)

  {new_tensor, t_index}
end)
|> Enum.chunk_every(h_size)
|> Enum.map(fn new_tensor_list ->
  new_tensor_list
  |> Enum.with_index()
  |> Enum.map(fn {{new_tensor, t_index}, v_index} ->
    # Invert color to check pattern
    cond do
      rem(v_index, 2) == rem(div(t_index, h_size), 2) ->
        Nx.reverse(new_tensor, axes: [2])

      true ->
        new_tensor
    end
  end)
  # Concatenate vertically
  |> Nx.concatenate(axis: 1)
end)
# Concatenate horizontally
|> Nx.concatenate()
# Trim to image size
|> Nx.slice([0, 0, 0], Tuple.to_list(img_shape))
|> Kino.Image.new()
```
