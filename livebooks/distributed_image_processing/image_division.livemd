# 画像分割

```elixir
Mix.install([
  {:httpoison, "~> 1.8"},
  {:evision, "~> 0.1"},
  {:kino, "~> 0.7"},
  {:nx, "~> 0.4"}
])
```

## 画像ダウンロード

```elixir
img_tensor =
  "https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png"
  |> HTTPoison.get!()
  |> then(& &1.body)
  # Evision で PNG 画像を読込
  |> Evision.imdecode(Evision.cv_IMREAD_COLOR())
  # Nx テンソルに変換
  |> Evision.Mat.to_nx(Nx.BinaryBackend)
  # BGR から RGB に変換
  |> Nx.reverse(axes: [2])
```

```elixir
# 画像の表示
Kino.Image.new(img_tensor)
```

## 画像の保存

```elixir
# Evision を使って保存するため、マトリックスに変換
img_mat =
  img_tensor
  |> Nx.reverse(axes: [2])
  |> Evision.Mat.from_nx_2d()
```

```elixir
# 指定したパスに保存する
img_path = "Lenna.png"

Evision.imwrite(img_path, img_mat)
```

```elixir
# 画像サイズ
shape = img_mat.shape

# 分割サイズ（分割した画像一つの幅、高さのピクセル数）
div_size = 64

# ファイル名
dst_file_ext = Path.extname(img_path)
dst_file_basename = Path.basename(img_path, dst_file_ext)
```

```elixir
# 画像リスト保存用関数
save_img_tensor_list = fn img_tensor_list, kind ->
  dst_files =
    Stream.unfold(0, fn counter -> {counter, counter + 1} end)
    |> Stream.map(&"#{dst_file_basename}_#{kind}_#{&1}#{dst_file_ext}")

  img_tensor_list
  |> Enum.zip(dst_files)
  |> Enum.map(fn {img_tensor, dst_file} ->
    img_mat =
      img_tensor
      |> Nx.reverse(axes: [2])
      |> Evision.Mat.from_nx_2d()

    Evision.imwrite(dst_file, img_mat)

    dst_file
  end)
end
```

## 縦に分割

```elixir
div_tensor_list = Nx.to_batched(img_tensor, div_size)
```

```elixir
# 分割した画像を並べて表示
div_tensor_list
|> Enum.map(&Kino.Image.new(&1))
|> Kino.Layout.grid(columns: 1)
```

```elixir
# 分割した画像をファイルに保存
dst_file_paths = save_img_tensor_list.(div_tensor_list, "h")
```

```elixir
# 分割したファイルを結合
imgs =
  Stream.unfold(0, fn counter -> {counter, counter + 1} end)
  |> Stream.map(&{&1, "#{dst_file_basename}_h_#{&1}#{dst_file_ext}"})
  |> Stream.take_while(fn {_, f} -> File.exists?(f) end)
  |> Enum.map(fn {index, file_name} ->
    new_tensor =
      file_name
      |> Evision.imread()
      |> Evision.Mat.to_nx(Nx.BinaryBackend)

    # 偶数の場合は色を反転
    case rem(index, 2) do
      0 ->
        Nx.reverse(new_tensor, axes: [2])

      _ ->
        new_tensor
    end
  end)
  # 結合
  |> Nx.concatenate()
  # トリミング
  |> Nx.slice([0, 0, 0], Tuple.to_list(shape))
  |> Kino.Image.new()
  |> dbg()
```

## 横に分割

```elixir
# to_batched では縦にしか分割できないため、縦横を変換してから分割する
img_tensor
|> Nx.transpose(axes: [1, 0, 2])
|> Kino.Image.new()
```

```elixir
div_tensor_list =
  img_tensor
  # 　縦横入れ替え
  |> Nx.transpose(axes: [1, 0, 2])
  # 分割
  |> Nx.to_batched(div_size)
  # 　縦横入れ替え
  |> Enum.map(&Nx.transpose(&1, axes: [1, 0, 2]))
  |> dbg()
```

```elixir
# 分割した画像を並べて表示
div_tensor_list
|> Enum.map(&Kino.Image.new(&1))
|> Kino.Layout.grid(columns: 8)
```

```elixir
# 分割した画像をファイルに保存
dst_file_paths = save_img_tensor_list.(div_tensor_list, "v")
```

```elixir
# 分割したファイルを結合
imgs =
  Stream.unfold(0, fn counter -> {counter, counter + 1} end)
  |> Stream.map(&{&1, "#{dst_file_basename}_v_#{&1}#{dst_file_ext}"})
  |> Stream.take_while(fn {_, f} -> File.exists?(f) end)
  |> Enum.map(fn {index, file_name} ->
    new_tensor =
      file_name
      |> Evision.imread()
      |> Evision.Mat.to_nx(Nx.BinaryBackend)

    # 偶数の場合は色を反転
    case rem(index, 2) do
      0 ->
        Nx.reverse(new_tensor, axes: [2])

      _ ->
        new_tensor
    end
  end)
  # 結合
  |> Nx.concatenate(axis: 1)
  # トリミング
  |> Nx.slice([0, 0, 0], Tuple.to_list(shape))
  |> Kino.Image.new()
  |> dbg()
```

## タイル状に分割

```elixir
div_tensor_list =
  img_tensor
  # 縦方向に分割
  |> Nx.to_batched(div_size)
  |> Enum.map(&Nx.transpose(&1, axes: [1, 0, 2]))
  # 横方向に分割
  |> Enum.flat_map(&Nx.to_batched(&1, div_size))
  |> Enum.map(&Nx.transpose(&1, axes: [1, 0, 2]))
```

```elixir
# 分割した画像を並べて表示
div_tensor_list
|> Enum.map(&Kino.Image.new(&1))
|> Kino.Layout.grid(columns: 8)
```

```elixir
# 分割した画像をファイルに保存
dst_file_paths = save_img_tensor_list.(div_tensor_list, "t")
```

```elixir
# 横方向の分割数を取得
{width, _, _} = shape
h_size = div(width, div_size)

# 分割したファイルを結合
imgs =
  Stream.unfold(0, fn counter -> {counter, counter + 1} end)
  |> Stream.map(&{&1, "#{dst_file_basename}_t_#{&1}#{dst_file_ext}"})
  |> Stream.take_while(fn {_, f} -> File.exists?(f) end)
  |> Enum.map(fn {t_index, file_name} ->
    new_tensor =
      file_name
      |> Evision.imread()
      |> Evision.Mat.to_nx(Nx.BinaryBackend)

    {new_tensor, t_index}
  end)
  |> Enum.chunk_every(h_size)
  |> Enum.map(fn new_tensor_list ->
    new_tensor_list
    |> Enum.with_index()
    |> Enum.map(fn {{new_tensor, t_index}, v_index} ->
      cond do
        rem(v_index, 2) == rem(div(t_index, h_size), 2) ->
          Nx.reverse(new_tensor, axes: [2])

        true ->
          new_tensor
      end
    end)
    # 横方向に結合
    |> Nx.concatenate(axis: 1)
  end)
  # 縦方向に結合
  |> Nx.concatenate()
  # トリミング
  |> Nx.slice([0, 0, 0], Tuple.to_list(shape))
  |> Kino.Image.new()
  |> dbg()
```
