# Tellus から標高データを取得する

```elixir
Mix.install(
  [
    {:nx, "~> 0.7"},
    {:evision, "~> 0.2"},
    {:exla, "~> 0.7"},
    {:req, "~> 0.5"},
    {:kino, "~> 0.13"},
    {:kino_maplibre, "~> 0.1"},
    {:kino_vega_lite, "~> 0.1"}
  ],
  config: [
    nx: [
      default_backend: EXLA.Backend
    ]
  ]
)
```

## 著作権表記

Credit: ASTER GDEM is courtesy of METI and NASA

## 情報の設定

```elixir
# Tellus のトークンを入力する
token_input = Kino.Input.password("Token")
```

## Tellus Traveler からデータを探す

Tellus Satellite Data Traveler API を使用する

API 仕様: https://www.tellusxdp.com/docs/travelers/

<!-- livebook:{"break_markdown":true} -->

### データセットの選択

```elixir
defmodule TellusTraveler do
  @base_path "https://www.tellusxdp.com/api/traveler/v1"
  @data_path "#{@base_path}/datasets"

  defp get_headers(token) do
    %{
      "Authorization" => "Bearer #{token}",
      "Content-Type" => "application/json"
    }
  end

  def get_datasets(token, is_order_required) do
    url = "#{@data_path}/?is_order_required=#{is_order_required}"
    headers = get_headers(token)

    url
    |> Req.get!(headers: headers)
    |> then(& &1.body["results"])
  end

  def get_dataset(token, dataset_id) do
    url = "#{@data_path}/#{dataset_id}/"
    headers = get_headers(token)

    url
    |> Req.get!(headers: headers)
    |> Map.get(:body)
  end

  def search(token, dataset_id, coordinates) do
    url =
      if is_list(dataset_id) do
        "#{@base_path}/data-search/"
      else
        "#{@data_path}/#{dataset_id}/data-search/"
      end

    headers = get_headers(token)

    request_body =
      %{
        intersects: %{
          type: "Polygon",
          coordinates: coordinates
        },
        query: %{},
        sortby: [
          %{
            field: "properties.start_datetime",
            direction: "asc"
          }
        ]
      }
      |> Map.merge(
        if is_list(dataset_id) do
          %{datasets: dataset_id}
        else
          %{}
        end
      )
      |> Jason.encode!()

    url
    |> Req.post!(body: request_body, headers: headers)
    |> then(& &1.body["features"])
  end

  def get_data_files(token, dataset_id, data_id) do
    url = "#{@data_path}/#{dataset_id}/data/#{data_id}/files/"
    headers = get_headers(token)

    url
    |> Req.get!(headers: headers)
    |> then(& &1.body["results"])
  end

  defp get_data_file_download_url(token, dataset_id, data_id, file_id) do
    url = "#{@data_path}/#{dataset_id}/data/#{data_id}/files/#{file_id}/download-url/"
    headers = get_headers(token)

    url
    |> Req.post!(headers: headers)
    |> then(& &1.body["download_url"])
  end

  def download(token, dataset_id, scene_id, dist \\ "/tmp/") do
    [dist, scene_id]
    |> Path.join()
    |> File.mkdir_p()

    token
    |> get_data_files(dataset_id, scene_id)
    |> Enum.map(fn file ->
      file_path = Path.join([dist, scene_id, file["name"]])

      unless File.exists?(file_path) do
        token
        |> get_data_file_download_url(dataset_id, scene_id, file["id"])
        |> Req.get!(into: File.stream!(file_path))
      end

      file_path
    end)
  end
end
```

```elixir
datasets =
  token_input
  |> Kino.Input.read()
  |> TellusTraveler.get_datasets(false)
```

```elixir
elevation_datasets =
  datasets
  |> Enum.filter(fn dataset ->
    dataset["permission"]["allow_network_type"] == "global" &&
      String.contains?(dataset["description"], "標高")
  end)

Kino.DataTable.new(elevation_datasets, keys: ["name", "id", "description"])
```

```elixir
dataset_id = "3f865d0b-6410-453f-b124-e0bf48544b45"
```

### シーンの選択

```elixir
mt_fuji_location = {138.73, 35.36}
```

```elixir
mt_fuji_rectangle = [
  [
    [elem(mt_fuji_location, 0) - 0.001, elem(mt_fuji_location, 1) - 0.001],
    [elem(mt_fuji_location, 0) + 0.001, elem(mt_fuji_location, 1) - 0.001],
    [elem(mt_fuji_location, 0) + 0.001, elem(mt_fuji_location, 1) + 0.001],
    [elem(mt_fuji_location, 0) - 0.001, elem(mt_fuji_location, 1) + 0.001],
    [elem(mt_fuji_location, 0) - 0.001, elem(mt_fuji_location, 1) - 0.001]
  ]
]
```

```elixir
scenes_list =
  token_input
  |> Kino.Input.read()
  |> TellusTraveler.search(dataset_id, mt_fuji_rectangle)
```

```elixir
mt_fuji_scene_id =
  scenes_list
  |> Enum.at(0)
  |> Map.get("id")
```

## データのダウンロード

```elixir
token_input
|> Kino.Input.read()
|> TellusTraveler.download(dataset_id, mt_fuji_scene_id)
```

## ダウンロードした画像を表示する

```elixir
"/tmp/#{mt_fuji_scene_id}"
|> File.ls!()
|> Enum.filter(fn filename -> Path.extname(filename) != ".txt" end)
|> Enum.sort()
|> Enum.map(fn filename ->
  ["/tmp", mt_fuji_scene_id, filename]
  |> Path.join()
  # 色が 16bit で格納されているため、 IMREAD_ANYDEPTH と IMREAD_ANYCOLOR を指定する
  |> Evision.imread(
    flags: Evision.Constant.cv_IMREAD_ANYDEPTH() + Evision.Constant.cv_IMREAD_ANYCOLOR()
  )
  # 大きすぎるのでリサイズ
  |> Evision.resize({640, 640})
end)
|> Kino.Layout.grid(columns: 2)
```

```elixir
mt_fuji_dem =
  "/tmp/#{mt_fuji_scene_id}"
  |> File.ls!()
  |> Enum.find(fn filename -> String.ends_with?(filename, "_dem.tif") end)
  |> then(&Path.join(["/tmp", mt_fuji_scene_id, &1]))
  |> Evision.imread(
    flags: Evision.Constant.cv_IMREAD_ANYDEPTH() + Evision.Constant.cv_IMREAD_ANYCOLOR()
  )
  |> Evision.Mat.to_nx(EXLA.Backend)
```

```elixir
{mt_fuji_min_dig, mt_fuji_max_dig} = {
  mt_fuji_dem |> Nx.reduce_min() |> Nx.to_number(),
  mt_fuji_dem |> Nx.reduce_max() |> Nx.to_number()
}
```

```elixir
mt_fuji_dem_u8 =
  mt_fuji_dem
  |> Nx.subtract(mt_fuji_min_dig)
  |> Nx.multiply(255 / (mt_fuji_max_dig - mt_fuji_min_dig))
  |> Nx.as_type(:u8)

Evision.resize(mt_fuji_dem_u8, {640, 640})
```

```elixir
jet_colormap =
  [
    [0, 0, 131],
    [0, 0, 135],
    [0, 0, 139],
    [0, 0, 143],
    [0, 0, 147],
    [0, 0, 151],
    [0, 0, 155],
    [0, 0, 159],
    [0, 0, 163],
    [0, 0, 167],
    [0, 0, 171],
    [0, 0, 175],
    [0, 0, 179],
    [0, 0, 183],
    [0, 0, 187],
    [0, 0, 191],
    [0, 0, 195],
    [0, 0, 199],
    [0, 0, 203],
    [0, 0, 207],
    [0, 0, 211],
    [0, 0, 215],
    [0, 0, 219],
    [0, 0, 223],
    [0, 0, 227],
    [0, 0, 231],
    [0, 0, 235],
    [0, 0, 239],
    [0, 0, 243],
    [0, 0, 247],
    [0, 0, 251],
    [0, 0, 255],
    [0, 4, 255],
    [0, 8, 255],
    [0, 12, 255],
    [0, 16, 255],
    [0, 20, 255],
    [0, 24, 255],
    [0, 28, 255],
    [0, 32, 255],
    [0, 36, 255],
    [0, 40, 255],
    [0, 44, 255],
    [0, 48, 255],
    [0, 52, 255],
    [0, 56, 255],
    [0, 60, 255],
    [0, 64, 255],
    [0, 68, 255],
    [0, 72, 255],
    [0, 76, 255],
    [0, 80, 255],
    [0, 84, 255],
    [0, 88, 255],
    [0, 92, 255],
    [0, 96, 255],
    [0, 100, 255],
    [0, 104, 255],
    [0, 108, 255],
    [0, 112, 255],
    [0, 116, 255],
    [0, 120, 255],
    [0, 124, 255],
    [0, 128, 255],
    [0, 131, 255],
    [0, 135, 255],
    [0, 139, 255],
    [0, 143, 255],
    [0, 147, 255],
    [0, 151, 255],
    [0, 155, 255],
    [0, 159, 255],
    [0, 163, 255],
    [0, 167, 255],
    [0, 171, 255],
    [0, 175, 255],
    [0, 179, 255],
    [0, 183, 255],
    [0, 187, 255],
    [0, 191, 255],
    [0, 195, 255],
    [0, 199, 255],
    [0, 203, 255],
    [0, 207, 255],
    [0, 211, 255],
    [0, 215, 255],
    [0, 219, 255],
    [0, 223, 255],
    [0, 227, 255],
    [0, 231, 255],
    [0, 235, 255],
    [0, 239, 255],
    [0, 243, 255],
    [0, 247, 255],
    [0, 251, 255],
    [0, 255, 255],
    [4, 255, 251],
    [8, 255, 247],
    [12, 255, 243],
    [16, 255, 239],
    [20, 255, 235],
    [24, 255, 231],
    [28, 255, 227],
    [32, 255, 223],
    [36, 255, 219],
    [40, 255, 215],
    [44, 255, 211],
    [48, 255, 207],
    [52, 255, 203],
    [56, 255, 199],
    [60, 255, 195],
    [64, 255, 191],
    [68, 255, 187],
    [72, 255, 183],
    [76, 255, 179],
    [80, 255, 175],
    [84, 255, 171],
    [88, 255, 167],
    [92, 255, 163],
    [96, 255, 159],
    [100, 255, 155],
    [104, 255, 151],
    [108, 255, 147],
    [112, 255, 143],
    [116, 255, 139],
    [120, 255, 135],
    [124, 255, 131],
    [128, 255, 128],
    [131, 255, 124],
    [135, 255, 120],
    [139, 255, 116],
    [143, 255, 112],
    [147, 255, 108],
    [151, 255, 104],
    [155, 255, 100],
    [159, 255, 96],
    [163, 255, 92],
    [167, 255, 88],
    [171, 255, 84],
    [175, 255, 80],
    [179, 255, 76],
    [183, 255, 72],
    [187, 255, 68],
    [191, 255, 64],
    [195, 255, 60],
    [199, 255, 56],
    [203, 255, 52],
    [207, 255, 48],
    [211, 255, 44],
    [215, 255, 40],
    [219, 255, 36],
    [223, 255, 32],
    [227, 255, 28],
    [231, 255, 24],
    [235, 255, 20],
    [239, 255, 16],
    [243, 255, 12],
    [247, 255, 8],
    [251, 255, 4],
    [255, 255, 0],
    [255, 251, 0],
    [255, 247, 0],
    [255, 243, 0],
    [255, 239, 0],
    [255, 235, 0],
    [255, 231, 0],
    [255, 227, 0],
    [255, 223, 0],
    [255, 219, 0],
    [255, 215, 0],
    [255, 211, 0],
    [255, 207, 0],
    [255, 203, 0],
    [255, 199, 0],
    [255, 195, 0],
    [255, 191, 0],
    [255, 187, 0],
    [255, 183, 0],
    [255, 179, 0],
    [255, 175, 0],
    [255, 171, 0],
    [255, 167, 0],
    [255, 163, 0],
    [255, 159, 0],
    [255, 155, 0],
    [255, 151, 0],
    [255, 147, 0],
    [255, 143, 0],
    [255, 139, 0],
    [255, 135, 0],
    [255, 131, 0],
    [255, 128, 0],
    [255, 124, 0],
    [255, 120, 0],
    [255, 116, 0],
    [255, 112, 0],
    [255, 108, 0],
    [255, 104, 0],
    [255, 100, 0],
    [255, 96, 0],
    [255, 92, 0],
    [255, 88, 0],
    [255, 84, 0],
    [255, 80, 0],
    [255, 76, 0],
    [255, 72, 0],
    [255, 68, 0],
    [255, 64, 0],
    [255, 60, 0],
    [255, 56, 0],
    [255, 52, 0],
    [255, 48, 0],
    [255, 44, 0],
    [255, 40, 0],
    [255, 36, 0],
    [255, 32, 0],
    [255, 28, 0],
    [255, 24, 0],
    [255, 20, 0],
    [255, 16, 0],
    [255, 12, 0],
    [255, 8, 0],
    [255, 4, 0],
    [255, 0, 0],
    [251, 0, 0],
    [247, 0, 0],
    [243, 0, 0],
    [239, 0, 0],
    [235, 0, 0],
    [231, 0, 0],
    [227, 0, 0],
    [223, 0, 0],
    [219, 0, 0],
    [215, 0, 0],
    [211, 0, 0],
    [207, 0, 0],
    [203, 0, 0],
    [199, 0, 0],
    [195, 0, 0],
    [191, 0, 0],
    [187, 0, 0],
    [183, 0, 0],
    [179, 0, 0],
    [175, 0, 0],
    [171, 0, 0],
    [167, 0, 0],
    [163, 0, 0],
    [159, 0, 0],
    [155, 0, 0],
    [151, 0, 0],
    [147, 0, 0],
    [143, 0, 0],
    [139, 0, 0],
    [135, 0, 0],
    [131, 0, 0],
    [128, 0, 0]
  ]
  |> Enum.reverse()
  |> Nx.tensor()
  |> Nx.tile([1, 1, 1])
  |> Nx.as_type(:u8)
  |> Nx.transpose(axes: [1, 0, 2])
  |> Evision.Mat.from_nx_2d()
```

```elixir
mt_fuji_dem_color =
  mt_fuji_dem_u8
  |> Evision.applyColorMap(jet_colormap)
  |> Evision.resize({640, 640})
```

## 標高をグラフ化する

```elixir
display_elevation_at_x = fn dem, x_index, width, max_y ->
  plot_data =
    dem[[x_index]]
    |> Nx.to_flat_list()
    |> Enum.with_index()
    |> Enum.map(fn {elevation, index} ->
      %{
        elevation: elevation,
        index: index
      }
    end)

  x_scale = %{"domain" => [0, 3601]}
  y_scale = %{"domain" => [-500, max_y]}

  VegaLite.new(width: width)
  |> VegaLite.data_from_values(plot_data)
  |> VegaLite.mark(:area)
  |> VegaLite.encode_field(:x, "index", type: :quantitative, scale: x_scale)
  |> VegaLite.encode_field(:y, "elevation", type: :quantitative, scale: y_scale)
end
```

```elixir
display_elevation_at_x.(mt_fuji_dem, 0, 700, 4000)
```

```elixir
max_index = mt_fuji_dem |> Nx.argmax() |> Nx.to_number()

max_x_index = div(max_index, 3601)
max_y_index = max_index - max_x_index * 3601

{max_x_index, max_y_index}
```

```elixir
mt_fuji_dem[[max_x_index, max_y_index]]
```

```elixir
display_elevation_at_x.(mt_fuji_dem, max_x_index, 700, 4000)
```

## グラフをアニメーションにする

```elixir
x_scale = %{"domain" => [0, 3601]}
y_scale = %{"domain" => [-500, 4000]}

widget =
  VegaLite.new(width: 700)
  |> VegaLite.mark(:area)
  |> VegaLite.encode_field(:x, "index", type: :quantitative, scale: x_scale)
  |> VegaLite.encode_field(:y, "elevation", type: :quantitative, scale: y_scale)
  |> Kino.VegaLite.new()
```

```elixir
animate = fn dem, x_index ->
  plot_data =
    dem[[x_index]]
    |> Nx.to_flat_list()
    |> Enum.with_index()
    |> Enum.map(fn {elevation, y_index} ->
      %{
        elevation: elevation,
        index: y_index
      }
    end)

  Kino.VegaLite.clear(widget)
  Kino.VegaLite.push_many(widget, plot_data)
end
```

```elixir
0..3600//20
|> Enum.map(fn x_index ->
  animate.(mt_fuji_dem, x_index)
  Process.sleep(100)
end)
```

## 富士山と大分市を比較する

```elixir
get_scene_id = fn location ->
  rectangle = [
    [
      [elem(location, 0) - 0.001, elem(location, 1) - 0.001],
      [elem(location, 0) + 0.001, elem(location, 1) - 0.001],
      [elem(location, 0) + 0.001, elem(location, 1) + 0.001],
      [elem(location, 0) - 0.001, elem(location, 1) + 0.001],
      [elem(location, 0) - 0.001, elem(location, 1) - 0.001]
    ]
  ]

  scenes_list =
    token_input
    |> Kino.Input.read()
    |> TellusTraveler.search(dataset_id, rectangle)

  scenes_list
  |> Enum.at(0)
  |> Map.get("id")
end
```

```elixir
oita_location = {131.64, 33.20}
```

```elixir
oita_scene_id = get_scene_id.(oita_location)
```

```elixir
token_input
|> Kino.Input.read()
|> TellusTraveler.download(dataset_id, oita_scene_id)
```

```elixir
oita_dem =
  "/tmp/#{oita_scene_id}"
  |> File.ls!()
  |> Enum.find(fn filename -> String.ends_with?(filename, "_dem.tif") end)
  |> then(&Path.join(["/tmp", oita_scene_id, &1]))
  |> Evision.imread(
    flags: Evision.Constant.cv_IMREAD_ANYDEPTH() + Evision.Constant.cv_IMREAD_ANYCOLOR()
  )
  |> Evision.Mat.to_nx(EXLA.Backend)

oita_dem_u8 =
  oita_dem
  |> Nx.subtract(mt_fuji_min_dig)
  |> Nx.multiply(255 / (mt_fuji_max_dig - mt_fuji_min_dig))
  |> Nx.as_type(:u8)

oita_dem_color = Evision.applyColorMap(oita_dem_u8, jet_colormap)

[mt_fuji_dem_color, oita_dem_color]
|> Kino.Layout.grid(columns: 2)
```

```elixir
oita_max_index = oita_dem |> Nx.argmax() |> Nx.to_number()
oita_max_x_index = div(oita_max_index, 3601)

[
  display_elevation_at_x.(mt_fuji_dem, max_x_index, 300, 4000),
  display_elevation_at_x.(oita_dem, oita_max_x_index, 300, 4000)
]
|> Kino.Layout.grid(columns: 2)
```

## 富士山とエベレストを比較する

```elixir
mt_everest_location = {86.92, 27.99}
```

```elixir
mt_everest_scene_id = get_scene_id.(mt_everest_location)
```

```elixir
token_input
|> Kino.Input.read()
|> TellusTraveler.download(dataset_id, mt_everest_scene_id)
```

```elixir
mt_everest_dem =
  "/tmp/#{mt_everest_scene_id}"
  |> File.ls!()
  |> Enum.find(fn filename -> String.ends_with?(filename, "_dem.tif") end)
  |> then(&Path.join(["/tmp", mt_everest_scene_id, &1]))
  |> Evision.imread(
    flags: Evision.Constant.cv_IMREAD_ANYDEPTH() + Evision.Constant.cv_IMREAD_ANYCOLOR()
  )
  |> Evision.Mat.to_nx(EXLA.Backend)

{mt_everest_min_dig, mt_everest_max_dig} = {
  mt_everest_dem |> Nx.reduce_min() |> Nx.to_number(),
  mt_everest_dem |> Nx.reduce_max() |> Nx.to_number()
}
```

```elixir
min_dig = Enum.min([mt_fuji_min_dig, mt_everest_min_dig])
max_dig = Enum.max([mt_fuji_max_dig, mt_everest_max_dig])

{min_dig, max_dig}
```

```elixir
get_heatmap = fn dem, min_dig, max_dig ->
  dem
  |> Nx.subtract(min_dig)
  |> Nx.multiply(256 / (max_dig - min_dig))
  |> Nx.as_type(:u8)
  |> Evision.applyColorMap(jet_colormap)
end
```

```elixir
[
  get_heatmap.(mt_everest_dem, min_dig, max_dig),
  get_heatmap.(mt_fuji_dem, min_dig, max_dig),
  get_heatmap.(oita_dem, min_dig, max_dig)
]
|> Kino.Layout.grid(columns: 3)
```

```elixir
mt_everest_max_x_index =
  mt_everest_dem
  |> Nx.argmax()
  |> Nx.to_number()
  |> div(3601)

[
  display_elevation_at_x.(mt_everest_dem, mt_everest_max_x_index, 200, 9000),
  display_elevation_at_x.(mt_fuji_dem, max_x_index, 200, 9000),
  display_elevation_at_x.(oita_dem, oita_max_x_index, 200, 9000)
]
|> Kino.Layout.grid(columns: 3)
```

## 海面上昇シミュレーション

```elixir
alpha =
  Nx.logical_and(Nx.greater(oita_dem, 0), Nx.less_equal(oita_dem, 10))
  |> Nx.select(255, 0)
  |> Nx.new_axis(-1)

alpha
|> Nx.as_type(:u8)
|> Evision.Mat.from_nx_2d()
|> Evision.resize({640, 640})
```

```elixir
bgra =
  [0, 0, 255]
  |> Nx.tensor()
  |> Nx.tile([3601, 3601, 1])
  |> then(&Nx.concatenate([&1, alpha], axis: 2))
  |> Nx.as_type(:u8)
  |> Evision.Mat.from_nx_2d()

Evision.resize(bgra, {640, 640})
```

```elixir
get_data_url = fn mat ->
  Evision.imencode(".png", mat)
  |> Base.encode64()
  |> then(&"data:image/png;base64,#{&1}")
end
```

```elixir
center = {131.5, 33.5}

coordinates = [
  [131 - 1 / 3600 / 2, 34 - 9 / 3600 / 2],
  [132 + 1 / 3600 / 2, 34 - 9 / 3600 / 2],
  [132 + 1 / 3600 / 2, 33 - 11 / 3600 / 2],
  [131 - 1 / 3600 / 2, 33 - 11 / 3600 / 2]
]

img_base64 = get_data_url.(bgra)

MapLibre.new(center: center, zoom: 8, style: :terrain)
|> MapLibre.add_source("image", type: :image, url: img_base64, coordinates: coordinates)
|> MapLibre.add_layer(
  id: "overlay",
  source: "image",
  type: :raster,
  paint: %{"raster-opacity" => 0.5}
)
```
